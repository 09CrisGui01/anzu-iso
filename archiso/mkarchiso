#! /bin/bash

PKGLIST=""
QUIET="y"
FORCE="n"
MOUNTFILE="$(pwd)/mounts"
IMG_TYPE="iso"

APPNAME=$(basename "${0}")

# usage: usage <exitvalue>
usage ()
{
    echo "usage ${APPNAME} [options] command <command options>"
    echo " general options:"
    echo "    -f               Force overwrite of working files/squashfs image/bootable image"
    echo "    -p PACKAGE(S)    Additional package(s) to install, can be used multiple times"
    echo "    -v               Enable verbose output."
    echo "    -h               This message."
    echo " commands:"
    echo "   create <dir>"
    echo "      create a base directory layout to work with"
    echo "      includes all specified packages"
    echo "   iso -p <bootloader> <dir> <image name>"
    echo "      build an iso image from the working dir"
    echo "   usb -p <bootloader> <dir> <image name>"
    echo "      build an iso image from the working dir"
    exit $1
}

while getopts 'i:P:p:a:t:fvh' arg; do
    case "${arg}" in
        p) PKGLIST="${PKGLIST} ${OPTARG}" ;;
        f) FORCE="y" ;;
        v) QUIET="n" ;;
        h|?) usage 0 ;;
        *) echo "invalid argument '${arg}'"; usage 1 ;;
    esac
done

#trim spaces
PKGLIST="$(echo $PKGLIST)"

shift $(($OPTIND - 1))
echo "ARGS: $@"

# do UID checking here so someone can at least get usage instructions
if [ "$EUID" != "0" ]; then
    echo "error: This script must be run as root."
    exit 1
fi

command_name="${1}"
work_dir=""
imgname=""

case "${command_name}" in
    create) work_dir="${2}"; imgname="none" ;;
    iso) work_dir="${2}"; imgname="${3}" ;;
    usb) work_dir="${2}"; imgname="${3}" ;;
    *) echo "invalid command name '${command_name}'"; usage 1 ;;
esac

[ "x${imgname}" = "x" ] && (echo "Image name must be specified" && usage 1)
[ "x${work_dir}" = "x" ] && (echo "Please specify a working directory" && usage 1)

echo "${APPNAME} : Configuration Settings"
echo "        working directory:   ${work_dir}"
echo "               image name:   ${imgname}"
echo "               image type:   ${IMG_TYPE}"

# usage: _pacman <packages>...
_pacman ()
{
    local ret
    if [ "${QUIET}" = "y" ]; then
        mkarchroot -f ${work_dir} $* 2>&1 >/dev/null
        ret=$?
    else
        mkarchroot -f ${work_dir} $*
        ret=$?
    fi

    # Cleanup
    find "${work_dir}" -name *.pacnew -name *.pacsave -name *.pacorig -delete

    if [ $ret -ne 0 ]; then
        exit 1
    fi
}

command_create () {
    echo "====> Creating working directory: ${work_dir}"
    mkdir -p "${work_dir}/iso/"
    mkdir -p "${work_dir}/root-image/"
    echo "# archiso isomounts file
# img - location of image/directory to mount relative to addons directory
# arch - architecture of this image
# mount point - absolute location on the post-initrd root
# type - either 'bind' or 'squashfs' for now

# syntax: <img> <arch> <mount point> <type>

root-image.sqfs i686 / squashfs
#root-image-x86_64.sqfs x86_64 / squashfs" > "${work_dir}/isomounts"

    echo "README for this archiso created directory

All directories in this dir, except for 'iso' will be squashed
with squashfs and put into the iso dir as iso/<dirname>.sqfs
This should be reflected in the isomounts file

The iso dir is later used to build the actual bootable iso.
...TODO..." > "${work_dir}/README"

    if [ "${PKGLIST}" != "" ]; then
        echo "====> Installing packages to '${work_dir}/root-image/'"
        _pacman "${PKGLIST}"

        echo "Cleaning up what we can"
        if [ -d "${work_dir}/root-image/boot/" ]; then
            # remove the initcpio images that were generated for the host system
            find "${work_dir}/root-image/boot" -name *.img -delete
        fi

        #TODO is this needed? do it at the Makefile level?
        if [ -d "${work_dir}/root-image/home/" ]; then
            echo "Creating default home directory"
            install -d -o1000 -g100 -m0755 "${work_dir}/root-image/home/arch"
        fi

        # delete a lot of unnecessary cache/log files
        kill_dirs="var/abs var/cache/man var/cache/pacman var/lib/pacman/sync var/log/* var/mail tmp/* initrd"
        for x in ${kill_dirs}; do
            if [ -e "${work_dir}/root-image/${x}" ]; then
                rm -rf "${work_dir}/root-image/${x}"
            fi
        done
    fi
}

# command_squash path image
command_squash () {
    echo "====> Generating SquashFS image ${imgname}"
    if [ -e "${imgname}" ]; then
        if [ "${FORCE}" = "y" ]; then
            echo -n "Removing old SquashFS image..."
            rm "${imgname}"
            echo "done."
        else
            echo "error: SquashFS image '${imgname}' already exists, aborting."
            exit 1
        fi
    fi

    echo "Creating SquashFS image. This may take some time..."
    start=$(date +%s)
    if [ "${QUIET}" = "y" ]; then
        mksquashfs "${work_dir}" "${imgname}" -noappend >/dev/null
    else
        mksquashfs "${work_dir}" "${imgname}" -noappend
    fi
    minutes=$(echo $start $(date +%s) | awk '{ printf "%0.2f",($2-$1)/60 }')
    echo "Image creation done in $minutes minutes."
}

command_image () {
    echo "====> Making bootable image"
    if [ -e "${imgname}" ]; then
        if [ "${FORCE}" = "y" ]; then
            echo "Removing existing bootable image..."
            rm -rf "${imgname}"
        else
            echo "error: Image '${imgname}' already exists, aborting."
            exit 1
        fi
    fi

    if [ ! -e "${MOUNTFILE}" ]; then
        echo "error: mount file '${MOUNTFILE}' does not exist, aborting."
        exit 1
    fi
    cp "${MOUNTFILE}" "${work_dir}/mounts"

    bootflags=""
    if [ "$PKGLIST" = "grub" -o "$PKGLIST" = "grub-gfx" ]; then
        #test for either (eww, gross)
        tst=0
        pacman -Qi grub >/dev/null 2>&1
        tst=$(($tst + $?))
        pacman -Qi grub-gfx >/dev/null 2>&1
        tst=$(($tst + $?))
        if [ $tst -ge 2 ]; then
            echo "grub or grub-gfx not found on host system. Cannot install!"
            exit 1
        fi

        if [ ! -e "${work_dir}/boot/grub/stage2_eltorito" ]; then
            echo "error: grub stage files not found in '${work_dir}/boot/grub"
            exit 1
        fi

        bootflags="-b boot/grub/stage2_eltorito"
    elif [ "$PKGLIST" = "isolinux" ]; then
        if ! pacman -Qi $PKGLIST >/dev/null 2>&1; then
            echo "$PKGLIST not found on host system. Cannot install!"
            exit 1
        fi

        if [ ! -e "${work_dir}/boot/isolinux/isolinux.bin" ]; then
            echo "error: isolinux bin file not found in '${work_dir}/boot/isolinux"
            exit 1
        fi

        bootflags="-b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat"
    else
        echo "No bootloader specified. Use the -p flag to specify"
        echo "  Supported Bootloaders:"
        echo "     grub"
        echo "     grub-gfx"
        echo "     isolinux"
        exit 1
    fi

# Go through the main commands in order. If 'all' was specified, then we want
# to do everything. Start with 'install'.
if [ "${command_name}" = "install"  ]; then
    command_install
fi
if [ "${command_name}" = "squash" ]; then
    command_squash
fi
if [ "${command_name}" = "image" ]; then
    command_image
fi

# vim:ts=4:sw=4:et:
